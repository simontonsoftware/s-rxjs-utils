import { ObjectWith } from "micro-dash";
import { map } from "rxjs/operators";

/**
 * Applies `buildDownstreamItem` to each item in the upstream array and emits the result. Each item is cached using the key generated by `buildCacheKey` so that the next emission contains references to the matching objects from the previous emission, without running `buildDownstreamItem` again. The cache is only held between successive emissions.
 *
 * This is useful e.g. when using the result in an `*ngFor` expression of an angular template, to prevent angular from rebuilding the inner component and to allow `OnPush` optimizations in the inner component.
 *
 * If multiple items in an upstream array have the same cache key, it will only call `buildDownstreamItem` once.
 *
 * ```ts
 * const mapWithCaching = mapAndCacheElements(
 *   (item) => item.toString(),
 *   (item) => item + 1
 * )
 * ```
 * ```
 * source:         -[1, 2]---[1, 2, 3]---[2]--|
 * mapWithCaching: -[2, 3]---[2, 3, 4]---[3]--|
 * ```
 */
export function mapAndCacheElements<
  UpstreamType,
  DownstreamType = UpstreamType
>(
  buildCacheKey: (upstreamItem: UpstreamType) => string,
  buildDownstreamItem: (upstreamItem: UpstreamType) => DownstreamType,
) {
  let cache: ObjectWith<DownstreamType> = {};

  return map((upstreamItems: UpstreamType[]) => {
    const nextCache: ObjectWith<DownstreamType> = {};

    const downstreamItems = upstreamItems.map((upstreamItem) => {
      const cacheKey = buildCacheKey(upstreamItem);

      let downstreamItem: DownstreamType;
      if (cache.hasOwnProperty(cacheKey)) {
        downstreamItem = cache[cacheKey];
      } else if (nextCache.hasOwnProperty(cacheKey)) {
        downstreamItem = nextCache[cacheKey];
      } else {
        downstreamItem = buildDownstreamItem(upstreamItem);
      }

      nextCache[cacheKey] = downstreamItem;
      return downstreamItem;
    });

    cache = nextCache;
    return downstreamItems;
  });
}
